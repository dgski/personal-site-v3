
    <!doctype html>
    <html>
        <head>
            <title> Collector Functions in Scheme</title>
            <link rel="stylesheet" type="text/css" href="/style.css">
            
            <meta name="title" content=" Collector Functions in Scheme">
            <meta name="description" content=" Building and Passing Lambda Sandwiches">
            <meta property="og:type" content="website">
            <meta property="og:title" content=" Collector Functions in Scheme">
	        <meta property="twitter:title" content=" Collector Functions in Scheme">
        </head>
        <body>
            <div class="post-content">
                <a style="color:lightgrey" href="/">By David Gorski</a>
                <h1 class="post-title"> Collector Functions in Scheme</h1>
                <em> Building and Passing Lambda Sandwiches</em>
                <div class="post-body">
                    <blank><p>The Collector paradigm is a functional way of assembling and processing collections of data. As a design pattern it also offers a few benefits, and at the very least provides a unique academic exercise.</p><p>I've recently been working through the classic book; <a href='https://www.goodreads.com/book/show/548914.The_Little_Schemer' >The Little Schemer</a>, which is a cute and concise introduction to Scheme. The Chapter covering this topic delivered the first real friction, so I took some time to chew through it, understand it, and expand its explanation.</p><p>Let's start by defining a function which takes a list of numbers, and uses the collector paradigm to sort the numbers into two categories, Odd and Even:</p><div class='code' >(define&nbsp;sep-odds<br>&nbsp;&nbsp;(lambda&nbsp;(lat&nbsp;col)<br>&nbsp;&nbsp;&nbsp;&nbsp;(cond<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((null?&nbsp;lat)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col&nbsp;'()&nbsp;'()))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((=&nbsp;(modulo&nbsp;(car&nbsp;lat)&nbsp;2)&nbsp;0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sep-odds&nbsp;(cdr&nbsp;lat)&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col&nbsp;odds&nbsp;(cons&nbsp;(car&nbsp;lat)&nbsp;evens)))))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(sep-odds&nbsp;(cdr&nbsp;lat)&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col&nbsp;(cons&nbsp;(car&nbsp;lat)&nbsp;odds)&nbsp;evens)))))))<br></div><p>This function will consume two arguments: a list of numbers (lat) and a collector function (col). Its body consist's of one <b>cond</b> statement with 3 branches:</p><table><tr><th>Branch                       </th><th> Description</th></tr><tr><td>(null? lat)                  </td><td> Checks if <b>lat</b> is empty</td></tr><tr><td>(= (modulo (car lat) 2) 0)   </td><td> Checks if the first entry in the list is even</td></tr><tr><td>else                         </td><td> Concludes first list entry must be odd</td></tr></table><p>Take a note as to how <b>sep-odds</b> recurs: It does not build a list in the simple way of functionally building up a collection. Instead, if <b>sep-odds</b> is to recur it builds a lambda function which will perform a particular task (in this case using <b>cons</b> to prepend the number to one of the lists) and then passes this lambda function to the next call of <b>sep-odds</b> as the <b>col</b> argument.</p><p>Wrapping a task in a lambda is a neat trick: It delays execution of the wrapped code until the lambda is called.</p><p>Another neat trick is that <b>sep-odds</b> stuffs the previous collector function (bound to <b>col</b> as a function parameter) into the new lambda's body. I like to visualize this as a sandwich, with previous collectors being stuffed inside new ones. Finally, when one of these lambdas is called, it does its work, and then calls the collector function embedded inside it.</p><p>For our <b>sep-odds</b> function, you may notice that we need to provide an initial collector. Let's get to it.</p><p><b>First Time with Scheme?</b> <i>Please Note: (car x) returns the first element of the list x, and (cdr x) returns list x excluding the first element.</i></p><p>We will define <b>list</b> as our 0th collector. This will be the very centre of the lambda function sandwich:</p><div class='code' >(define&nbsp;col-0&nbsp;list)<br></div><p>Now let's step through what happens when we perform the following function call:</p><div class='code' >(sep-odds&nbsp;'(1&nbsp;2&nbsp;3&nbsp;4)&nbsp;col-0)&nbsp;;&nbsp;return&nbsp;value&nbsp;-&gt;&nbsp;((1&nbsp;3)&nbsp;(2&nbsp;4))<br></div><p><b>(car lat)</b> for the first call of sep-odds is <b>1</b>, therefore the third condition (<b>else</b>) is matched. This will generate a new lambda with <b>col-0</b> as <b>col</b> and <b>1 (car lat)</b> inside it. For clarity, we will label this newly generated lambda function as <b>col-1</b>:</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;1&nbsp;to&nbsp;the&nbsp;odds&nbsp;list<br>(define&nbsp;col-1<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-0&nbsp;(cons&nbsp;1&nbsp;odds)&nbsp;evens)))<br></div><p>This conditional branch will then call sep-odds again, with the rest of the list <b>(cdr lat)</b> and the newly-generated <b>col-1</b> as arguments:</p><div class='code' >(sep-odds&nbsp;'(2&nbsp;3&nbsp;4)&nbsp;col-1)<br></div><p>After this second function call the second conditional branch <b>(= (modulo (car lat) 2) 0)</b> is triggered as 2 is an even number. Same story again: a new lambda is built, but this time <b>col-1</b> is bound to <b>col</b>:</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;2&nbsp;to&nbsp;the&nbsp;evens&nbsp;list<br>(define&nbsp;col-2<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-1&nbsp;odds&nbsp;(cons&nbsp;2&nbsp;evens))))<br></div><p>Now <b>col-2</b> and the remainder of the list will serve as the arguments for the <b>sep-odds</b> recursive call:</p><div class='code' >(sep-odds&nbsp;'(3&nbsp;4)&nbsp;col-2)<br></div><p>We repeat, again with an odd number (<b>3</b>):</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;3&nbsp;to&nbsp;the&nbsp;odds&nbsp;list<br>(define&nbsp;col-3<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-2&nbsp;(cons&nbsp;3&nbsp;odds)&nbsp;evens)))<br></div><p>and our next call:</p><div class='code' >(sep-odds&nbsp;'(4)&nbsp;col-3)<br></div><p>Again, with an even number (<b>4</b>):</p><div class='code' >;&nbsp;consumes&nbsp;two&nbsp;lists&nbsp;(odds&nbsp;and&nbsp;evens)&nbsp;and&nbsp;adds&nbsp;4&nbsp;to&nbsp;the&nbsp;evens&nbsp;list<br>(define&nbsp;col-4<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-3&nbsp;odds&nbsp;(cons&nbsp;4&nbsp;evens))))<br></div><p>Finally, since the input list is empty, the <b>null?</b> conditional is triggered with this final call:</p><div class='code' >(sep-odds&nbsp;'()&nbsp;col-4)<br></div><p>That <b>null?</b> conditional applies the <b>col</b> function. In this case it is our latest, <b>col-4</b>:</p><div class='code' >;&nbsp;excerpt:<br>((null?&nbsp;lat)&nbsp;(col-4&nbsp;'()&nbsp;'()))<br></div><p>At this moment our sandwich is at its juiciest. Each layer takes an input from the previous one, as the layers are stripped away. We will begin with the outside 'bun' of the sandwich and go inwards. Each collector function calls the collector embedded within it:</p><div class='code' >(define&nbsp;col-4<br>&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;(col-3&nbsp;odds&nbsp;(cons&nbsp;4&nbsp;evens))))<br>;&nbsp;&nbsp;&nbsp;|____|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;col-3<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-2&nbsp;(cons&nbsp;3&nbsp;odds)&nbsp;evens)))<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|____|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;col-2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-1&nbsp;odds&nbsp;(cons&nbsp;2&nbsp;evens))))<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|____|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define&nbsp;col-1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-0&nbsp;(cons&nbsp;1&nbsp;odds)&nbsp;evens)))<br><br></div><p>We are lucky we used labels, In reality the lambda generated looks like this:</p><div class='code' >(lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((lambda&nbsp;(odds&nbsp;evens)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(col-0&nbsp;(cons&nbsp;1&nbsp;odds)&nbsp;evens))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;odds&nbsp;(cons&nbsp;2&nbsp;evens)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;3&nbsp;odds)&nbsp;evens))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;odds&nbsp;(cons&nbsp;4&nbsp;evens)))<br></div><p>And this is how the function calls look with the computed values of the arguments:</p><div class='code' >1.&nbsp;(col-4&nbsp;'()&nbsp;'())<br>2.&nbsp;(col-3&nbsp;'()&nbsp;'(4))<br>3.&nbsp;(col-2&nbsp;'(3)&nbsp;'(4))<br>4.&nbsp;(col-1&nbsp;'(3)&nbsp;'(2&nbsp;4))<br>5.&nbsp;(col-0&nbsp;'(1&nbsp;3)&nbsp;'(2&nbsp;4))<br>6.&nbsp;(list&nbsp;'(1&nbsp;3)&nbsp;'(2&nbsp;4))<br>7.&nbsp;((1&nbsp;3)&nbsp;(2&nbsp;4))<br></div><p>All of these expressions have the same value.</p><p>So now the big question: Why? Why complicate things like this? Why not just use multiple lists as arguments to gather the data we want?</p><p>Well, Collector functions offer two advantages: Delayed Execution, and Continuations.</p><p>To address the first point, in this example, each generated lambda is doing something relatively inexpensive: using <b>cons</b> to prepend a number to a list. But what if it was performing some sort of expensive operation? For example: performing operations on a matrix with massive proportions, or rendering graphics. Perhaps there is hypothetical example where we do not want to do anything computationally expensive until the data input has been completely verified, from start to finish? In that case a collector paradigm would work well. Building the collector works sort of as a type of manifest or queue, of operations to be performed.</p><p>Secondly, if you have a function which represents a series of steps, and each step has their own state, you can travel back to these states. In effect, you save a snapshot of that point in time. And in Scheme, since you can pass function along; you can pass these snapshots around. This gives you flexibility to return back to times where data was valid or matched some sort of pattern. One thing that comes to mind is traversing a Tree data structure and if you are exploring the children of a branch, you can pass forward a collector that represents that root, until you reach something you need and feed that data into the collector.</p></blank>
                </div>
                <strong>Post By <a href="/"> David Gorski</a> on 2018/10/16 13:34:00</strong>
                <div class="post-bottom">
                    <strong>Liked this article?</strong><br>
                    Subscribe via <a href="/posts/rss/index.xml">RSS</a> or <a href="https://twitter.com/thedavidgorski">Twitter</a>
                </div>
            </div>
        </body>
    </html>
